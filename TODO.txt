tache A
• x Coder les fonctions DIST_NAIF et DIST_NAIF_REC.
• x Tester la validité de votre implémentation sur les instances Inst_0000010_44.adn,
Inst_0000010_7.adn et Inst_0000010_8.adn qui ont pour distance d’édition 10, 8 et 2.
• x Pour évaluer les performances de cette méthode, évaluez jusqu’à quelle taille d’instance vous pouvez
résoudre les instances fournies en moins d’une minute.

---
tache B
• x Coder les deux fonctions DIST_1 et SOL_1, ainsi qu’une fonction PROG_DYN qui prend en entrée
seulement les mots x et y et qui renvoie à la fois la distance d(x, y) et un alignement optimal. Tester
ces fonctions sur plusieurs instances.
• Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Est-ce que la courbe obtenue correspond à la complexité théorique ?
Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes chacune.
• Estimer la quantité de mémoire utilisée par PROG_DYN pour une instance de très grande taille.
---
tache C
• x Coder la fonction DIST_2 et la tester sur plusieurs instances.
• Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Est-ce que la courbe obtenue correspond à la complexité théorique ?
Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes chacune.
• Comparer les résultats à ceux obtenus pour la fonction DIST_1 précédente.
• Estimer la quantité de mémoire utilisée par DIST_2 pour une instance de très grande taille.
---
tache D
• x Coder les fonctions correspondant à cette méthode “diviser pour régner”.
• Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes
chacune.
• Estimer la consommation mémoire nécessaire au fonctionnement de cette méthode.
---
question 29
• Comparez expérimentalement la complexité temporelle de SOL_2 à celle de SOL_1. On ne demande pas de preuve théorique.

breakdown:
--- TEMPS
• DIST_1 SOL_1 Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Est-ce que la courbe obtenue correspond à la complexité théorique ?
Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes chacune.
• DIST_2 Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Est-ce que la courbe obtenue correspond à la complexité théorique ?
Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes chacune.
• “diviser pour régner” Tracer la courbe de consommation de temps CPU en fonction de la taille |x| du premier mot du
couple des instances fournies. Vous pouvez vous limiter aux instances nécessitant moins de 10 minutes
chacune.

--- MEM
• DIST_NAIF Estimer la consommation mémoire nécessaire au fonctionnement de cette méthode. Dans le cas
d’une consommation mémoire qui est réalisée uniquement au début d’un programme, cela peut-être
fait simplement en lançant la commande linux top pendant le début de l’exécution (l’affichage de
top est mis à jour en appuyant sur espace). Il se peut aussi que la consommation mémoire demandée
soit trop importante et que le système stoppe alors le programme.
• Estimer la quantité de mémoire utilisée par PROG_DYN pour une instance de très grande taille.
• Estimer la quantité de mémoire utilisée par DIST_2 pour une instance de très grande taille.
• Estimer la consommation mémoire nécessaire au fonctionnement de cette méthode (“diviser pour régner”).

-- AUTRES: voir le truc